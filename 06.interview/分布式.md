### [CAP理论](https://blog.csdn.net/weixin_43899069/article/details/121310759)

- Consistency（一致性）
  - 一致性是指“**所有节点同时看到相同的数据**”，也就是说在更新操作成功并返回到客户端后，所有节点在同一时间的数据完全一致，所有节点所拥有的数据都是最新版本。
- Availability（可用性）
  - 可用性指的是“**任何时候，读写都是成功的**”，即服务一直可用，而且响应时间在正常范围内。比如系统稳定性到了3个9、4个9，即99.9%、99.99%。
- Partition tolerance（分区容忍性）
  - 分区容错性是指“**当部分结点出现消息丢失，或分区故障时，分布式系统仍然能够继续运行**”，即系统容忍网络出现分区，且在遇到某个结点或网络分区之间出现不可达的情况下，仍然能够对外提供满足一致性和可用性的服务。



### ZK（CP）

#### [选主机制](https://blog.csdn.net/liaofeifeifeifei/article/details/119712395)

**启动阶段的leader选举**
zk集群至少要有3个节点，假如有5个节点1、2、3、4、5先后启动，它们启动时的zxid都是一样的(设为0):

```
->节点1进入looking选举状态，给自己投票，发出(0,1)，此时当选节点票数=1<节点总数的一半=2.5，故节点1仍保持looking状态继续等待选举

->节点2进入looking选举状态，给自己投票，发出(0,2)，myid为2最大，2当选，但此时当选节点票数=2<节点总数的一半=2.5，故节点2仍保持looking状态继续等待选举

->节点3进入looking选举状态，给自己投票，发出(0,3)，myid为3最大，3当选，且此时当选节点票数=3>节点总数的一半=2.5，故节点3当选leader

->节点4进入looking选举状态，给自己投票，发出(0,4)，但此时集群leader已选出，所以节点4仍成为follwer

->节点5进入looking选举状态，给自己投票，发出(0,5)，但此时集群leader已选出，所以节点5仍成为follwer

->选举完成后，leader的状态由looking变为leading，follower的状态由looking变为following

总的来说，启动阶段的选举当选的必然为位于中间的节点
```

**运行阶段的选举**

```
运行阶段每个节点的zxid都可能不同，但选举原则与启动阶段一样，都是先比较zxid,再比较myid，假如主节点3运行中挂掉了，其他所有从节点全部进入looking状态，节点1、2、4、5的zxid为121、122、124、125，且各从节点都推举自己为下一个leader，节点1发出（121,1），节点2发出（122，2），节点4发出（124，4），由于节点4的zxid比1、2的大，故4当选，且当选节点票数=3>总节点数/2=5/2=2.5,所以4当选新一代leader，节点5发出（125，5），但此时已经选举出leader，所以5成为follwer，最后leader变更状态为leading，follower变更为following
```



#### ZK节点类型

1. 持久节点(PERSISTENT)
   - 持久节点，创建后一直存在，直到主动删除此节点。
2. 持久顺序节点(PERSISTENT_SEQUENTIAL)
   - 持久顺序节点，创建后一直存在，直到主动删除此节点。在ZK中，每个父节点会为它的第一级子节点维护一份时序，记录每个子节点创建的先后顺序。
3. 临时节点(EPHEMERAL)
   - **临时节点在客户端会话失效后节点自动清除**(临时节点消失时间)。临时节点下面不能创建子节点。
4. 顺序临时节点(EPHEMERAL_SEQUENTIAL)
   - 临时节点在客户端会话失效后节点自动清除。临时节点下面不能创建子节点。父节点getChildren会获得顺序的节点列表。

> 顺序节点的名字必须是唯一的。



#### ZK节点角色

1. leadering - 领导者
   - 负责管理整个集群,保证数据的全局一致性
   - 负责数据事务的相关操作
   - 转发数据非事务操作给从节点
2. followering - 追随者/跟随者
   - 实时从主节点拉取数据从而保持数据的一致性
   - 负责数据非事务相关的操作
   - 转发数据事务操作给主节点
3. observering - 观察者
   - 除了没有选举权之外,其他操作和Follower一样

> 往往会将一个集群中90%的节点设置为observer



#### ZK可以解决什么问题？如何解决数据一致性的

paxos算法

三种角色

在 Paxos 算法中有三种角色，分别具有三种不同的行为。但很多时候，一个进程可能同 时充当着多种角色。

- Proposer:提案者，提出提案（Proposal）；
- Acceptor:表决者；
- Learner:学习者(同步者，即Proposer决议形成，将所有形成的决议发送给Learners)

两个阶段

- prepare阶段，这个阶段主要是准备一个编号为N的提案，首先向所有决议者（Acceptor）发送prepare请求，用于试探是否支持该编号的提议。
- accept阶段，当一阶段提议收到了超过半数的响应，则开始正式下发提案内容proposal，如果过半则提案提交成功，广播给所有learner。



#### BASE理论（ZK是基于base的）

- 基本可用
  基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。
  - 响应时间的损失：	
  - 功能上的损失：
-  软状态
  软状态，是指允许系统数据存在的中间状态，并认为该中间状态的存在不会影响系统的
  整体可用性，即允许系统主机间进行数据同步的过程存在一定延时。软状态，其实就是一种
  灰度状态，过渡状态。
- 最终一致性
  最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到
  一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需
  要实时保证系统数据的强一致性。



#### ZK失效情况

ZK 集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在 ZK节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。



#### [ZK脑裂问题](https://blog.csdn.net/zxylwj/article/details/103608916)

zookeeper可能引发脑裂现象，是指在多机房（网络分区）部署中，若出现网络连接问题，形成多个分区，则可能出现脑裂问题，会导致数据不一致。（严重故障，违反zookeeper实现一致性原则）



### ZK与eruka对比

ZK 遵循的是 CP 原则，即保证了一致性，但牺牲了可用性。体现在哪里呢？

```
当 Leader 宕机后，ZK 集群会马上进行新的 Leader 的选举。但选举时长一般在 200 毫秒
内，最长不超过 60 秒，整个选举期间 ZK 集群是不接受客户端的读写操作的，即 ZK 集群是
处于瘫痪状态的。所以，其不满足可用性。
```

```
Eureka 保证了 AP，牺牲了 CP。即其保证了可用性，但无法保证一致性。
```



### 分布式锁

#### 应用场景

1. 分布式系统，系统集群，java锁无效
2. 操作共享资源，比如库里的唯一数据
3. 同步访问，即多个进程同时操作资源

#### 解决方案

1. redis的分布式锁。setnx key value ex 10s，Redisson。

   watch dog.

2. Zookeeper。临时节点，顺序节点

3. 数据库，比如mysql，主键或唯一索引的唯一性



#### Redis做分布式锁用什么命令

SETNX

格式：setnx key value 将key的值设置为value，当且仅当key不存在，

若给定的key已经存在，则SETNX不做任何操作。

SETNX是【SET if Not eXIsts】（如果不存在，则SET）的简写

加锁：set key value nx ex 10s

释放锁：delete key