#### 三大范式

1. 第一范式(1NF)：属性不可分割，即**每个属性都是不可分割的原子项**。(实体的属性即表中的列)
2. 第二范式(2NF)：满足第一范式；且不存在部分依赖，即**非主属性必须完全依赖于主属性**。(主属性即主键；完全依赖是针对于联合主键的情况，非主键列不能只依赖于主键的一部分)
3. 第三范式(3NF)：满足第二范式；且不存在传递依赖，即**非主属性不能与非主属性之间有依赖关系**，非主属性必须直接依赖于主属性，不能间接依赖主属性。（A -> B, B ->C, A -> C）
4. 

#### 简述mysql中索引类型有哪些，以及对数据库的性能的影响？

普通索引：允许被索引的数据列包含重复的值
唯一索引：可以保证数据记录的唯一性
主键索引：是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字
primary key来创建
联合素引：索引可以履盖多个数据列
全文索引：通过建立倒排索引，可以极大的提升检索效率，解决判断字段是否包含的问题，是目前搜索引掌使用的
一种关键技术
索引可以极大地提高数据的查询速度
通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能
但是会降低插入、删除、更新表的速度，因为在执行这些写操作的时候，还要操作素引文件
索引需要占物理空间，除了数据表占数据空间之外，每一个素引还要占一定的物理空间，如果要简历聚绩索引，那
么需要的空间就会更大，如果非聚旗索引很多，一旦聚簇素引改变，那么所有非聚簇素引都会跟着变

#### 简述Myisam和Innodb的区别？

InnoDB存储引擎：主要面向OLTP(Online Transaction Processing,在线事务处理）方面的应用，是第一个完整支
持ACID事务的存储引擎（BDB第一个支持事务的存储引擎，已经停止开发）。
特点：
1支持行锁
2支持外键
3支持自动增加列AUTO_INCREMENT属性
4支持事务
5支持MVCC模式的读写
6读的效率低于MYISAM
7.写的效率高优于MYISAM
8.适合频繁修改以及设计到安全性较高的应用
9.清空整个表的时候，Innodb是一行一行的删除，

MyISAM存储引擎：是MySQL官方提供的存储引擎，主要面向OLAP(Online Analytical Processing,在线分析处理）方
面的应用。
特点：
1独立于操作系统，当建立一个MyISAM存储引擎的表时，就会在本地磁盘建立三个文件，例如我建立tb_demo
表，那么会生成以下三个文件tb_demo.frm,tb_demo.MYD,tb_demo.MYI
2不支持事务
3支持表锁和全文索引
4 MyISAM存储引掌表由MYD和MY组成，MYD用来存放数据文件，MYI用来存放索引文件。MySQL数据库只缓存

其素引文件，数据文件的缓存交给操作系统本身来完成；
5 MySQL5.0版本开始，MyISAM默认支持256T的单表数据；
6.选择密集型的表：MYISAM存储引掌在韩选大量数据时非常迅速，这是他最突出的优点
7.读的效率优于InnoDB
8.写的效率低于InnoDB
9.适合查询以及插入为主的应用
10.清空整个表的时候，MYISAM则会新建表

#### 什么是MVCC?

1、MVCC
MVCC,全称Multi-Version Concurrency Control,即多版本并发控制。MVCC是一种并发控制的方法，一般
在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。
MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读写冲突，做到即使有读写冲
突时，也能做到不加锁，非阻塞并发读。
2、当前读
像select lock in share mode(共享锁）,select for update;update,insert,delete(排他锁）这些操作都是一种
当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会
对读取的记录进行加锁，
3、快照读（提高数据库的并发查询能力）
像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别
下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本
并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然
是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本
4、当前读、快照读、MVCC关系
MVCC多版本并发控制指的是维持一个数据的多个版本，使得读写操作没有冲突，快照读是MySQL为实现
ICC的一个非阻塞读功能，MVCC模块在MySQL中的具体实现是由三个隐式字段，undo日志、read view三个组件来实现的

#### MVCC解决的问题是什么？

数据库并发场景有三种，分别为
1、读读：不存在任何问题，也不需要并发控制
2、读写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读、幻读、不可重复读
3、写写：有线程安全问题，可能存在更新丢失问题
MVCC是一种用来解决读写冲突的无锁并发控源，也就是为事务分配单项增长的时间截，为每个修改保存一个
版本，版本与事务时间截关联，读操作只读该事务开始前的数据库的快照，所以MVCC可以为数据库解决以下问题
1、在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并
发读写的性能
2、解决脏读、幻读、不可重复读等事务隔离问题，但是不能解决更新丢失问题

#### MVCC实现原理是什么？

mvcc的实现原理主要依赖于记录中的三个隐藏字段，undolog,read view来实现的。
隐藏字段
每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID等字段
DB_TRX_ID
6字节，最近修改事务id,记录创建这条记录或者最后一次修改该记录的事务id
DB_ROLL_PTR
7字节，回滚指针，指向这条记录的上一个版本，用于配合undolog,指向上一个旧版本
DB_ROWJD
6字节，隐藏的主键，如果数据表没有主键，那么innodb会自动生成一个6字节的row_id
记录如图所示：
![image-20220827155658731](http://rgwngkfs9.hn-bkt.clouddn.com/image-20220827155658731.png)
在上图中，DB_ROW_ID是数据库默认为该行记录生成的唯一隐式主键，DB_TRX_D是当前操作该记录的事务

ID,DB_ROLL_PTR是一个回滚指针，用于配合undo日志，指向上一个旧版本
undo log
ndolog被称之为回滚日志，表示在进行insert,delete,update操作的时候产生的方便回滚的日志
当进行insert操作的时候，产生的undolog只在事务回滚的时候需要，并且在事务提交之后可以被立刻丢弃
当进行update和delete操作的时候，产生的undolog不仅仅在事务回滚的时候需要，在快照读的时候也需
要，所以不能随便删除，只有在快照读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除（当数
据发生更新和删除操作的时候都只是设置一下老记录的deleted_bit,并不是真正的将过时的记录删除，因为为了
节省磁盘空间，innodb有专门的purge线程来清除deleted_bit为true的记录，如果某个记录的deleted_id为true,
并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定时可以被清除的）

#### MySQL的隔离级别有哪些？



#### MySQL采用B+树的优缺点

1.单一节点存储更多的元素，使得查询的IO次数更少。

2.所有查询都要查找到叶子节点，查询性能稳定。

3.所有叶子节点形成有序链表，便于范围查询。



#### 慢sql优化

1. 开启慢查询日志，设置超过几秒为慢SQL语句，抓取慢SQL语句
2. 通过explain查看执行计划，对慢SQL语句分析
3. 创建索引并调整语句，再查看执行计划，对比调优结果

> 数据冗余也可以作为一种优化方案



#### join连接方式

1. 内连接Inner join（**默认方式**）
2. 左外连接Left join
3. 右外连接Right join
4. 全连接Full join



#### select * from t for update

select * from t for update 会等待行锁释放之后，返回查询结果。
select * from t for update nowait 不等待行锁释放，提示锁冲突，不返回结果
select * from t for update wait 5 等待5秒，若行锁仍未释放，则提示锁冲突，不返回结果
select * from t for update skip locked 查询返回查询结果，但忽略有行锁的记录



#### on和where的对比

**区别**

1. 先执行on，后执行where；on是建立关联关系在生成临时表时候执行，where是在临时表生成后对数据进行筛选的。
2. 比如两个表进行left join连接查询结果，where会对查询的结果进行过滤， on会返回驱动表的所有数据。
3. left join按照条件关联，不管是否为真，都返回左边表的数据。



#### 数据冗余

冗余数据三种方案：

1. 服务同步双写法能够很容易的实现数据冗余
2. 为了降低时延，可以优化为服务异步双写法
3. 为了屏蔽“冗余数据”对服务带来的复杂性，可以优化为线下异步双写法

保证数据一致性的方案：

1. 最简单的方式，线下脚本扫全量数据比对
2. 提高效率的方式，线下脚本扫增量数据比对
3. 最实时的方式，线上检测“消息对”



#### mysql5.7和8.0的区别

1. mysql8.0的索引可以被隐藏和显示，当一个索引隐藏时，他不会被查询优化器所使用
2. mysql8.0新增了“SET PERSIST”命令
3. 从mysql8.0开始，数据库的缺省编码将改为utf8mb4，包含了所有emoji字符
4. 8.0新增窗口函数



#### mysql引擎

```
show engines;
```

> 引擎设置是基于表的



#### InnoDB存储引擎改为MyISAM存储引擎

修改事务会有问题么？

//todo 



#### 直接修改mysql引擎的问题

会花费很长时间

- 解决方案

  改为创建一张新表，导入数据



#### mysql日志

- binlog（二进制日志）
  - innodb
  - myisam
- redolog(前滚)
  - innodb
- undolog（回滚）
  - innodb
- error log（错误日志）
- slow query log（慢查询日志）
- general log(一般查询日志)



#### binlog格式

- Statement（Statement-Based Replication,SBR）：每一条会修改数据的 SQL 都会记录在 binlog 中。
- Row（Row-Based Replication,RBR）：不记录 SQL 语句上下文信息，仅保存哪条记录被修改。
- Mixed（Mixed-Based Replication,MBR）：Statement 和 Row 的混合体。
  

#### 嵌套算法

//todo