### [CAP理论](https://blog.csdn.net/weixin_43899069/article/details/121310759)

- Consistency（一致性）
  - 一致性是指“**所有节点同时看到相同的数据**”，也就是说在更新操作成功并返回到客户端后，所有节点在同一时间的数据完全一致，所有节点所拥有的数据都是最新版本。
- Availability（可用性）
  - 可用性指的是“**任何时候，读写都是成功的**”，即服务一直可用，而且响应时间在正常范围内。比如系统稳定性到了3个9、4个9，即99.9%、99.99%。
- Partition tolerance（分区容忍性）
  - 分区容错性是指“**当部分结点出现消息丢失，或分区故障时，分布式系统仍然能够继续运行**”，即系统容忍网络出现分区，且在遇到某个结点或网络分区之间出现不可达的情况下，仍然能够对外提供满足一致性和可用性的服务。



### ZK（CP）

#### [选主机制](https://blog.csdn.net/liaofeifeifeifei/article/details/119712395)

**启动阶段的leader选举**
zk集群至少要有3个节点，假如有5个节点1、2、3、4、5先后启动，它们启动时的zxid都是一样的(设为0):

```
->节点1进入looking选举状态，给自己投票，发出(0,1)，此时当选节点票数=1<节点总数的一半=2.5，故节点1仍保持looking状态继续等待选举

->节点2进入looking选举状态，给自己投票，发出(0,2)，myid为2最大，2当选，但此时当选节点票数=2<节点总数的一半=2.5，故节点2仍保持looking状态继续等待选举

->节点3进入looking选举状态，给自己投票，发出(0,3)，myid为3最大，3当选，且此时当选节点票数=3>节点总数的一半=2.5，故节点3当选leader

->节点4进入looking选举状态，给自己投票，发出(0,4)，但此时集群leader已选出，所以节点4仍成为follwer

->节点5进入looking选举状态，给自己投票，发出(0,5)，但此时集群leader已选出，所以节点5仍成为follwer

->选举完成后，leader的状态由looking变为leading，follower的状态由looking变为following

总的来说，启动阶段的选举当选的必然为位于中间的节点
```

**运行阶段的选举**

```
运行阶段每个节点的zxid都可能不同，但选举原则与启动阶段一样，都是先比较zxid,再比较myid，假如主节点3运行中挂掉了，其他所有从节点全部进入looking状态，节点1、2、4、5的zxid为121、122、124、125，且各从节点都推举自己为下一个leader，节点1发出（121,1），节点2发出（122，2），节点4发出（124，4），由于节点4的zxid比1、2的大，故4当选，且当选节点票数=3>总节点数/2=5/2=2.5,所以4当选新一代leader，节点5发出（125，5），但此时已经选举出leader，所以5成为follwer，最后leader变更状态为leading，follower变更为following
```



#### ZK节点类型

1. 持久节点(PERSISTENT)
   - 持久节点，创建后一直存在，直到主动删除此节点。
2. 持久顺序节点(PERSISTENT_SEQUENTIAL)
   - 持久顺序节点，创建后一直存在，直到主动删除此节点。在ZK中，每个父节点会为它的第一级子节点维护一份时序，记录每个子节点创建的先后顺序。
3. 临时节点(EPHEMERAL)
   - **临时节点在客户端会话失效后节点自动清除**(临时节点消失时间)。临时节点下面不能创建子节点。
4. 顺序临时节点(EPHEMERAL_SEQUENTIAL)
   - 临时节点在客户端会话失效后节点自动清除。临时节点下面不能创建子节点。父节点getChildren会获得顺序的节点列表。

> 顺序节点的名字必须是唯一的。



#### ZK节点角色

1. leadering - 领导者
   - 负责管理整个集群,保证数据的全局一致性
   - 负责数据事务的相关操作
   - 转发数据非事务操作给从节点
2. followering - 追随者/跟随者
   - 实时从主节点拉取数据从而保持数据的一致性
   - 负责数据非事务相关的操作
   - 转发数据事务操作给主节点
3. observering - 观察者
   - 除了没有选举权之外,其他操作和Follower一样

> 往往会将一个集群中90%的节点设置为observer



#### ZK可以解决什么问题？如何解决数据一致性的

paxos算法

三种角色

在 Paxos 算法中有三种角色，分别具有三种不同的行为。但很多时候，一个进程可能同 时充当着多种角色。

- Proposer:提案者，提出提案（Proposal）；
- Acceptor:表决者；
- Learner:学习者(同步者，即Proposer决议形成，将所有形成的决议发送给Learners)

两个阶段

- prepare阶段，这个阶段主要是准备一个编号为N的提案，首先向所有决议者（Acceptor）发送prepare请求，用于试探是否支持该编号的提议。
- accept阶段，当一阶段提议收到了超过半数的响应，则开始正式下发提案内容proposal，如果过半则提案提交成功，广播给所有learner。



#### BASE理论（ZK是基于base的）

- 基本可用
  基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。
  - 响应时间的损失：	
  - 功能上的损失：
-  软状态
  软状态，是指允许系统数据存在的中间状态，并认为该中间状态的存在不会影响系统的
  整体可用性，即允许系统主机间进行数据同步的过程存在一定延时。软状态，其实就是一种
  灰度状态，过渡状态。
- 最终一致性
  最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到
  一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需
  要实时保证系统数据的强一致性。



#### ZK失效情况

ZK 集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在 ZK节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。



#### [ZK脑裂问题](https://blog.csdn.net/zxylwj/article/details/103608916)

zookeeper可能引发脑裂现象，是指在多机房（网络分区）部署中，若出现网络连接问题，形成多个分区，则可能出现脑裂问题，会导致数据不一致。（严重故障，违反zookeeper实现一致性原则）



### ZK与eruka对比

ZK 遵循的是 CP 原则，即保证了一致性，但牺牲了可用性。体现在哪里呢？

```
当 Leader 宕机后，ZK 集群会马上进行新的 Leader 的选举。但选举时长一般在 200 毫秒
内，最长不超过 60 秒，整个选举期间 ZK 集群是不接受客户端的读写操作的，即 ZK 集群是
处于瘫痪状态的。所以，其不满足可用性。
```

```
Eureka 保证了 AP，牺牲了 CP。即其保证了可用性，但无法保证一致性。
```



###  分布式锁

#### 应用场景

1. 分布式系统，系统集群，java锁无效
2. 操作共享资源，比如库里的唯一数据
3. 同步访问，即多个进程同时操作资源

#### 解决方案

1. redis的分布式锁。setnx key value ex 10s，Redisson。

   watch dog.

2. Zookeeper。临时节点，顺序节点

3. 数据库，比如mysql，主键或唯一索引的唯一性



#### Redis做分布式锁用什么命令

SETNX

格式：setnx key value 将key的值设置为value，当且仅当key不存在，

若给定的key已经存在，则SETNX不做任何操作。

SETNX是【SET if Not eXIsts】（如果不存在，则SET）的简写

加锁：set key value nx ex 10s

释放锁：delete key



#### Redis做分布式锁产生死锁

情况1：加锁，没有释放锁。需要加释放锁的操作，比如 delete key。

情况2：加锁后，程序还没有执行释放锁，程序挂了，需要用key的过期机制。



#### Redis如何做分布式锁

假设有两个服务A、B都希望获得锁，执行过程大致如下:

Step1:服务A为了获得锁，向Redis发起如下命令: SET productid:ldck Oxx9p03001 NX EX 30000其中，"productld"由自己定义，可以是与本次业务有关的lid，"Oxx9p03001"是一串随机值，必须保证全局唯—，“NX"指的是当且仅当key(也就是案例中的"productld:lock")在Redis中不存在时，返回执行成功，否则执行失败。"EX 30000"指的是在30秒后，key将被自动删除。执行命令后返回成功，表明服务成功的获得了锁。

Step2:服务B为了获得锁，向Redis发起同样的命令:SET productld:lock 0000111 NX EX 30000
由于Redis内已经存在同名key，且并未过期，因此命令执行失败，服务B未能获得锁。服务B进入循环请求状态，比如每隔1秒钟(自行设置]向Redis发送请求，直到执行成功并获得锁。

Step3:服务A的业务代码执行时长超过了30秒，导致key超时，因此Redis自动删除了key。此时服务B再次发送命令执行成功，假设本次诘求中设置的value值为0000222。此时需要在服务A中对key进行续期。

Step4:服务A执行完毕，为了释放锁，服务A会主动向Redis发起册除key的请求。注意:在删除key之前，一定要判断服务A持有的value与Redis内存储的value是否一致。比如当前场景下，Redis中的锁早就不是服务A持有的那一把了，而是由服务2创建，如果贸然使用服务A持有的key来删除锁，则会误将服务2的锁释放掉。此外，由于删除锁时涉及到一系列判断逻辑，因此一般使用lua脚本，具体如下:



### 分布式系统中的幂等

幂等(idempotent、idempotence)是一个数学与计算机学概念，常见于抽象代数中。

在编程中，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。

例如，“getUsername()和setTrue()"函数就是一个幂等函数.更复杂的操作幂等保证是利用唯一交易号(流水号)实现.我的理解:幂等就是一个操作，不论执行多少次，产生的效果和返回的结果都是一样的



操作:查询,set固定值。逻辑删除。set固定值。

流程:分布式系统中，网络调用，主试机制。

#### 幂等的解决方案

1.查询操作
查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作;

2删除操作
删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，越除的数据多条，返回结果多个。

3.唯—索引
防止新增脏数据。比如:支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建多个资金账户，那么给资金账户表中的用户ID加唯一索引，所以一个用户新增成功一个资金账户记录。要点:唯一索引或唯一组合索引来防止新增数据存在脏数据〔当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在了，返回结果即可。

4.token机制
防止页面重复提交。

**业务要求**:页面的数据只能被点击提交一次;

**发生原因**:由于重复点击或者网络重发，或者nginx重发等情况会导致数据被重复提交;

**解决办法**:集群环境采用token 加 redis(redis单线程的，处理需要排队);单JVM环境:采用token 加 redis 或token 加jvm锁。

**处理流程**：

1.数据提交前要向服务的申请token，token放到redis 或jvm 内存，token有效时间;

2.提交后后台校验token，同时删除 token，生成新的token返回。

**token特点**:要申请，—次有效性，可以限流。

注意: redis 要用删除操作来判断token，删除成功代表 token校验通过。

5.traceld
操作时唯—的。



#### 为什么Cookie无法防止CSRF攻击，而token可以？

CSRF (Cross Site Request Forgery)一般被翻译为 跨站请求伪造。那么什么是跨站请求伪造呢？说简单一点
用你的身份去发送一些对你不友好的请求。举个简单的例子：

小壮登录了某网上银行，他来到了网上银行的帖子区，看到一个帖子下面有一个链接写着“科学理财，年收益率
70%",小壮好奇的点开了这个链接，结果发现自己的账户少了10000元。这是这么回事呢？原来黑客在链接中藏
了一个请求，这个请求直接利用小壮的身份给银行发送了一个转账请求，也就是通过你的Cookie向银行发出请求。

<a src=http://www.mybank.com/Transfer?bankld=11&money=10000&gt;科学理财，年收益率70%&lt;17I原因是
进行Session认证的时候，我们一般使用Cookie来存储Sessionld,当我们登陆后后端生成一个Sessionld放在
Cookie中返回给客户端，服务端通过Redis或者其他存储工具记录保存着这个Sessionid,客户端登录以后每次请
求都会带上这个Sessionld,服务端通过这个Sessionld来标示你这个人。如果别人通过cookie拿到了Sessionld
后就可以代替你的身份访问系统了。

Session认证中Cookie中的Sessionld是由浏览器发送到服务端的，借助这个特性，攻击者就可以通过让用户误
点攻击链接，达到攻击效果。

但是，我们使用token的话就不会存在这个问题，在我们登录成功获得token之后，一般会选择存放在local
storage中。然后我们在前端通过某些方式会给每个发到后端的请求加上这个token,这样就不会出现CSRF漏洞的
问题。因为，即使有个你点击了非法链接发送了请求到服务端，这个非法请求是不会携带token的，所以这个请
求将是非法的。

#### 分布式架构下，Session共享有什么方案？

1.不要有session:但是确实在某些场景下，是可以没有session的，其实在很多接口类系统当中，都提倡【API
无状态服务】；也就是每一次的接口访问，都不依赖于session、不依赖于前一次的接口访问，用jwt的
token;

2.存入cookie中：将session存储到cookie中，但是缺点也很明显，例如每次请求都得带着session,数据存储在
客户端本地，是有风险的；

3.session同步：对个服务器之间同步session,这样可以保证每个服务器上都有全部的session信息，不过当服
务器数量比较多的时候，同步是会有延迟甚至同步失败；

4.我们现在的系统会把session放到Redis中存储，虽然架构上变得复杂，并且需要多访问一次Redis,但是这种
方案带来的好处也是很大的：实现session共享，可以水平扩展（增加Redis服务器）,服务器重启session不
丢失（不过也要注意session在Redis中的刷新/失效机制）,不仅可以跨服务器session共享，甚至可以跨平台
(例如网页端和APP端）进行共享。

5.使用Nginx(或其他复杂均衡软硬件）中的ip绑定策略，同一个ip只能在指定的同一个机器访问，但是这样做
风险也比较大，而且也是去了负载均衡的意义；