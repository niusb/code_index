#### 三大范式

1. 第一范式(1NF)：属性不可分割，即**每个属性都是不可分割的原子项**。(实体的属性即表中的列)
2. 第二范式(2NF)：满足第一范式；且不存在部分依赖，即**非主属性必须完全依赖于主属性**。(主属性即主键；完全依赖是针对于联合主键的情况，非主键列不能只依赖于主键的一部分)
3. 第三范式(3NF)：满足第二范式；且不存在传递依赖，即**非主属性不能与非主属性之间有依赖关系**，非主属性必须直接依赖于主属性，不能间接依赖主属性。（A -> B, B ->C, A -> C）



#### MySQL采用B+树的优缺点

1.单一节点存储更多的元素，使得查询的IO次数更少。

2.所有查询都要查找到叶子节点，查询性能稳定。

3.所有叶子节点形成有序链表，便于范围查询。



#### 慢sql优化

1. 开启慢查询日志，设置超过几秒为慢SQL语句，抓取慢SQL语句
2. 通过explain查看执行计划，对慢SQL语句分析
3. 创建索引并调整语句，再查看执行计划，对比调优结果

> 数据冗余也可以作为一种优化方案



#### join连接方式

1. 内连接Inner join（**默认方式**）
2. 左外连接Left join
3. 右外连接Right join
4. 全连接Full join



#### select * from t for update

select * from t for update 会等待行锁释放之后，返回查询结果。
select * from t for update nowait 不等待行锁释放，提示锁冲突，不返回结果
select * from t for update wait 5 等待5秒，若行锁仍未释放，则提示锁冲突，不返回结果
select * from t for update skip locked 查询返回查询结果，但忽略有行锁的记录



#### on和where的对比

##### 区别

1. 先执行on，后执行where；on是建立关联关系在生成临时表时候执行，where是在临时表生成后对数据进行筛选的。
2. 比如两个表进行left join连接查询结果，where会对查询的结果进行过滤， on会返回驱动表的所有数据。
3. left join按照条件关联，不管是否为真，都返回左边表的数据。



#### 数据冗余

冗余数据三种方案：

1. 服务同步双写法能够很容易的实现数据冗余
2. 为了降低时延，可以优化为服务异步双写法
3. 为了屏蔽“冗余数据”对服务带来的复杂性，可以优化为线下异步双写法

保证数据一致性的方案：

1. 最简单的方式，线下脚本扫全量数据比对
2. 提高效率的方式，线下脚本扫增量数据比对
3. 最实时的方式，线上检测“消息对”



#### mysql5.7和8.0的区别

1. mysql8.0的索引可以被隐藏和显示，当一个索引隐藏时，他不会被查询优化器所使用
2. mysql8.0新增了“SET PERSIST”命令
3. 从mysql8.0开始，数据库的缺省编码将改为utf8mb4，包含了所有emoji字符
4. 8.0新增窗口函数



#### mysql引擎

```
show engines;
```

> 引擎设置是基于表的



#### InnoDB存储引擎改为MyISAM存储引擎

修改事务会有问题么？

//todo 



#### 直接修改mysql引擎的问题

会花费很长时间

- 解决方案

  改为创建一张新表，导入数据



#### mysql日志

- binlog（二进制日志）
  - innodb
  - myisam
- redolog(前滚)
  - innodb
- undolog（回滚）
  - innodb
- error log（错误日志）
- slow query log（慢查询日志）
- general log(一般查询日志)



#### binlog格式

- Statement（Statement-Based Replication,SBR）：每一条会修改数据的 SQL 都会记录在 binlog 中。
- Row（Row-Based Replication,RBR）：不记录 SQL 语句上下文信息，仅保存哪条记录被修改。
- Mixed（Mixed-Based Replication,MBR）：Statement 和 Row 的混合体。
  

#### 嵌套算法

//todo